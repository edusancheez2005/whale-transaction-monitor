"""
Data Models for the Opportunity Engine

Defines structured data classes for market analysis results and trading signals.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any
from enum import Enum


class SignalType(Enum):
    """Types of trading signals."""
    HIGH_CONFIDENCE_BUY = "HIGH_CONFIDENCE_BUY"
    HIGH_CONFIDENCE_SELL = "HIGH_CONFIDENCE_SELL"
    MODERATE_BUY = "MODERATE_BUY"
    MODERATE_SELL = "MODERATE_SELL"
    NO_SIGNAL = "NO_SIGNAL"


class HeuristicResult(Enum):
    """Results of individual heuristic checks."""
    PASS = "PASS"
    FAIL = "FAIL"
    INSUFFICIENT_DATA = "INSUFFICIENT_DATA"


@dataclass
class TokenInfo:
    """Information about the token being analyzed."""
    symbol: Optional[str] = None
    contract_address: str = ""
    chain: str = ""
    decimals: Optional[int] = None


@dataclass
class TransactionTrigger:
    """Information about the transaction that triggered the analysis."""
    hash: str
    from_address: str
    to_address: str
    value_usd: float
    classification: str  # BUY, SELL, STAKING, etc.
    timestamp: datetime = field(default_factory=datetime.utcnow)


@dataclass
class MarketHeuristics:
    """Results of technical analysis heuristics."""
    
    # Price trend analysis
    price_above_ema: Optional[HeuristicResult] = None
    price_below_ema: Optional[HeuristicResult] = None
    current_price: Optional[float] = None
    ema_20: Optional[float] = None
    
    # Volume analysis
    volume_surge: Optional[HeuristicResult] = None
    current_volume: Optional[float] = None
    avg_volume_24h: Optional[float] = None
    volume_ratio: Optional[float] = None
    
    # RSI analysis
    rsi_check: Optional[HeuristicResult] = None
    rsi_value: Optional[float] = None
    rsi_threshold_upper: float = 75.0
    rsi_threshold_lower: float = 25.0
    
    # Overall scores
    buy_score: float = 0.0
    sell_score: float = 0.0
    
    # Data quality
    data_points_analyzed: int = 0
    insufficient_data: bool = False
    
    def get_passing_heuristics(self, signal_type: str) -> List[str]:
        """Get list of heuristics that passed for the given signal type."""
        passing = []
        
        if signal_type.upper() == "BUY":
            if self.price_above_ema == HeuristicResult.PASS:
                passing.append("Price is in short-term uptrend (above 20-period EMA)")
            if self.volume_surge == HeuristicResult.PASS:
                passing.append("Volume is surging, confirming market interest")
            if self.rsi_check == HeuristicResult.PASS:
                passing.append(f"Momentum is strong but not overbought (RSI: {self.rsi_value:.1f})")
                
        elif signal_type.upper() == "SELL":
            if self.price_below_ema == HeuristicResult.PASS:
                passing.append("Price is in short-term downtrend (below 20-period EMA)")
            if self.volume_surge == HeuristicResult.PASS:
                passing.append("Selling volume is spiking, confirming downward pressure")
            if self.rsi_check == HeuristicResult.PASS:
                passing.append(f"Token is not oversold, room for further decline (RSI: {self.rsi_value:.1f})")
        
        return passing


@dataclass
class OpportunitySignal:
    """
    A complete trading opportunity signal generated by the engine.
    
    This is the final output that gets sent to the UI or alert system.
    """
    
    # Core signal information
    signal_type: SignalType
    confidence_score: float
    token: TokenInfo
    trigger_transaction: TransactionTrigger
    
    # Analysis results
    heuristics: MarketHeuristics
    reasoning: List[str] = field(default_factory=list)
    
    # Market context
    market_data_snippet: Optional[Dict[str, Any]] = None
    
    # Metadata
    generated_at: datetime = field(default_factory=datetime.utcnow)
    analysis_duration_ms: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the signal to a dictionary for JSON serialization."""
        return {
            "signal_type": self.signal_type.value,
            "confidence_score": self.confidence_score,
            "token": {
                "symbol": self.token.symbol,
                "contract_address": self.token.contract_address,
                "chain": self.token.chain,
                "decimals": self.token.decimals
            },
            "trigger_transaction": {
                "hash": self.trigger_transaction.hash,
                "from_address": self.trigger_transaction.from_address,
                "to_address": self.trigger_transaction.to_address,
                "value_usd": self.trigger_transaction.value_usd,
                "classification": self.trigger_transaction.classification,
                "timestamp": self.trigger_transaction.timestamp.isoformat()
            },
            "reasoning": self.reasoning,
            "heuristics": {
                "current_price": self.heuristics.current_price,
                "ema_20": self.heuristics.ema_20,
                "current_volume": self.heuristics.current_volume,
                "avg_volume_24h": self.heuristics.avg_volume_24h,
                "volume_ratio": self.heuristics.volume_ratio,
                "rsi_value": self.heuristics.rsi_value,
                "buy_score": self.heuristics.buy_score,
                "sell_score": self.heuristics.sell_score,
                "data_points_analyzed": self.heuristics.data_points_analyzed
            },
            "market_data_snippet": self.market_data_snippet,
            "generated_at": self.generated_at.isoformat(),
            "analysis_duration_ms": self.analysis_duration_ms
        }
    
    def get_alert_summary(self) -> str:
        """Generate a human-readable summary for alerts."""
        signal_emoji = "ðŸŸ¢" if "BUY" in self.signal_type.value else "ðŸ”´"
        
        summary = f"{signal_emoji} {self.signal_type.value} Signal for {self.token.symbol or 'Unknown Token'}\n"
        summary += f"ðŸ’° Trigger: ${self.trigger_transaction.value_usd:,.0f} {self.trigger_transaction.classification}\n"
        summary += f"ðŸŽ¯ Confidence: {self.confidence_score:.1%}\n\n"
        
        summary += "ðŸ“Š Key Insights:\n"
        for reason in self.reasoning:
            summary += f"â€¢ {reason}\n"
        
        return summary 